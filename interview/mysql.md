# 什么是sql
```
    结构化查询语言  
    
```

# 数据库三大范式
```
    第一范式：每个列都不可以再拆分
    第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分
    第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键
    
```

# mysql有关权限的表都有哪几个
```
    user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
    db权限表：记录各个帐号在各个数据库上的操作权限。
    table_priv权限表：记录数据表级的操作权限。
    columns_priv权限表：记录数据列级的操作权限。
    host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响
    
```

# MySQL的binlog有有几种录入格式？分别有什么区别？
```
    statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
        由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
    row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，
        会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
    mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row

```

# MyISAM索引与InnoDB索引的区别
```
    InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
    InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
    MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
    InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效

```

# 什么是索引
```
    索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
    索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
    更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的

```

# 索引的基本原理
```
    索引的原理很简单，就是把无序的数据变成有序的查询
        1、把创建了索引的列的内容进行排序
        2、对排序结果生成倒排表
        3、在倒排表内容上拼上数据地址链
        4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
```


# Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
```
    read uncommited ：读到未提交数据
    read committed：脏读，不可重复读
    repeatable read：可重读(默认)
    serializable ：串行事物
```


# 数据库中的事务
```
（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。
（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存

```

# MyISAM索引与InnoDB索引的区别
```
    InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
    InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
    MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
    InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

```

# 常用的索引类型
```
    主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
    唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
    普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
    全文索引： 是目前搜索引擎使用的一种关键技术

```

# 什么是聚簇索引？何时使用聚簇索引与非聚簇索引
```
    聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
    非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，
        当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

```

# 什么是脏读？幻读？不可重复读
```
    脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
    不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
    幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

```

# 数据库的乐观锁和悲观锁是什么？怎么实现的
```
    数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
    悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
    乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现
    
```

# 什么是存储过程？
```
    存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快

```

# UNION与UNION ALL的区别？
```
    如果使用UNION ALL，不会合并重复的记录行
    效率 UNION 高于 UNION ALL
    
```

# SQL的生命周期
```
    应用服务器与数据库服务器建立一个连接
    数据库进程拿到请求sql
    解析并生成执行计划，执行
    读取数据到内存并进行逻辑处理
    通过步骤一的连接，发送结果到客户端
    关掉连接，释放资源
```

全面的地址: https://blog.csdn.net/ThinkWon/article/details/104778621