# Redis为什么这么快
```
    1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
    2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
    3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    4、使用多路 I/O 复用模型，非阻塞 IO；
    5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

```

# Redis 的持久化机制是什么？各自的优缺点？
```
    RDB：是Redis DataBase缩写快照
        RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期
          
        优点：
            1、只有一个文件 dump.rdb，方便持久化。
            2、容灾性好，一个文件可以保存到安全的磁盘。
            3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
            4.相对于数据集大时，比 AOF 的启动效率更高
        缺点：
            1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
            2、AOF（Append-only file)持久化方式：是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件
            
    AOF：持久化(即Append Only File持久化)
        将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复
        
        优点:
            1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
            2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
            3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
        缺点：
            1、AOF 文件比 RDB 文件大，且恢复速度慢。
            2、数据集大的时候，比 rdb 启动效率低。
    
```

# Redis持久化数据和缓存怎么做扩容？
```
    如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
    如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。

```

# Redis的内存淘汰策略有哪些
```
    全局的键空间选择性移除
        noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
        allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
        allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
        
    设置过期时间的键空间选择性移除
        volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
        volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
        volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除
        
```

# Redis事务的三个阶段
```
    事务开始 MULTI
    命令入队
    事务执行 EXEC
    事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排
    
```

全面的信息：https://www.cnblogs.com/javazhiyin/p/13839357.html